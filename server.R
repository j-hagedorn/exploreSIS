## server.R ##

  shinyServer(
    function(input, output) { 
      
      ## REACTIVE SUBSETS ## 
      # Generated by reactive expressions to cache selected values 
      
      sisInput <- reactive({  
        scrub_sis %<>% 
          filter(as.Date(sis_date) >= input$dateRange[1]
                 & as.Date(sis_date) <= input$dateRange[2])
      })
      
      sisByAgency <- reactive({  
        
        region_filt <- if (input$region == "All") {
          levels(sisInput()$PIHP)
        } else input$region
        
        agency_filt <- if (input$agency == "All") {
          levels(sisInput()$agency)
        } else input$agency
        
        sisInput() %>% 
          filter(PIHP %in% region_filt
                 & agency %in% agency_filt)
          
      })
      
      per_wk <- reactive({
        
        per_wk <- 
          sisByAgency() %>%
          # Filter out expired assessments (> 3 yrs old)
          filter(due - as.Date(sis_date) <= (365 * 3)) %>%
          # Note we still use unfiltered dataset here to calc 
          # cumsum over wks without the date filter applied
          filter(as.POSIXct(sis_date) >= as.POSIXct("2011-12-12")
                 & as.Date(sis_date) <= Sys.Date()) %>%
          group_by(sis_yrwk) %>%
          summarize(n = n()) %>%
          rename(week = sis_yrwk) %>%
          mutate(week = as.Date(week),
                 avg = NA,
                 need = NA) %>%
          ungroup()
        
        if ((max(per_wk$week) + 7) > most_recent) {
          # If filtered dataset does contain most recent date, leave it be
          per_wk <- per_wk
        } else {
          # Create empty per week entries between last in seq and most recent in entire dataset
          new_wk <- seq.Date(from = max(per_wk$week) + 7, to = most_recent, by = "week") 
          new_wk <- as.data.frame(new_wk)
          new_wk %<>% rename(week = new_wk) %>% mutate(n = 0, avg = NA, need = NA)
          per_wk %<>% rbind(new_wk)
        }
        
      })
      
      on_track_vars <- reactive({
        
        region_filt <- if (input$region == "All") {
          levels(sisInput()$PIHP)
        } else input$region
        
        agency_filt <- if (input$agency == "All") {
          levels(sisInput()$agency)
        } else input$agency
        
        # Generate list of reactive vars filtered based on inputs
        # to be used in calculations for 'on_track' and 'on_track_what_if' viz
        
        # Calculate average per week
        # Note that average per week is calculated for assessments completed within past 90 days
        # If a CMH has no assessments in the previous 90 days, an error is generated 
        avg_per_wk <- round(median(per_wk()$n[as.POSIXct(per_wk()$week) >= as.POSIXct(most_recent - 90)], 
                                 na.rm = T), digits = 0)
        
        recent_int <- length(unique(sisByAgency()$interviewer[as.POSIXct(sisByAgency()$sis_date) >= as.POSIXct(most_recent - 90)]))

        avg_person_wk <- ceiling( avg_per_wk / recent_int )
        
        total_needed <- 
          totals %>% 
          filter(region %in% region_filt
                 & agency %in% agency_filt) %>%
          summarize(total = sum(total, na.rm = T))
        
        
        # Output as named list
        list(avg_per_wk = avg_per_wk,
             recent_int = recent_int,
             avg_person_wk = avg_person_wk,
             total_needed = total_needed[1,1])
        
      })
      
      sec2Input <- reactive({
        
        q2 %<>% 
          filter(as.Date(sis_date) >= input$dateRange[1]
                 & as.Date(sis_date) <= input$dateRange[2])
        
      })
      
      tos2Input <- reactive({
        
        sec2Input() %>%
          group_by(PIHP, agency, section_desc, item_desc, 
                   type, frequency, DST) %>%
          summarize(n = n(),
                    type_tot = sum(type_n),
                    frequency_tot = sum(frequency_n),
                    DST_tot = sum(DST_n)) %>%
          ungroup()
        
      })
      
      sec3Input <- reactive({
        
        q3 %<>% 
          filter(as.Date(sis_date) >= input$dateRange[1]
                 & as.Date(sis_date) <= input$dateRange[2])
        
      })
      
      tos3Input <- reactive({
        
        sec3Input() %>%
          group_by(PIHP, agency, item_desc, type, 
                   frequency, DST) %>%
          summarize(n = n(),
                    type_tot = sum(type_n),
                    frequency_tot = sum(frequency_n),
                    DST_tot = sum(DST_n)) %>%
          ungroup()
        
      })

      sec1Input <- reactive({
        
        sisInput() %>%
          select(fake_id, PIHP, agency, sis_date,  
                 starts_with("Q1")) %>%
          select(fake_id, PIHP, agency, sis_date,  
                 ends_with("support")) %>%
          gather(item,score,Q1A1_ExMedSupport:Q1B13_ExBehSupport) %>%
          mutate(item = gsub("ExMedSupport", "", item),
                 item = gsub("ExBehSupport", "", item),
                 level = car::recode(score,
                                     "0 = 'No Support Needed';
                                     1 = 'Some Support Needed';
                                     2 = 'Extensive Support Needed'")) %>%
          left_join(needs, by = "item") %>%
          select(fake_id,PIHP,agency,sis_date, 
                 section,section_desc,item,item_desc,qol,
                 need_svc,score,
                 refer_ot,refer_nurs,refer_sp,refer_pt,refer_diet,
                 level)
        
      })
      
      s1_3Input <- reactive({
        
        q2_filt <-
          sec2Input() %>%
          select(fake_id,PIHP,agency,sis_date,
                 section,section_desc,item,item_desc,qol,
                 need_svc,score,
                 refer_ot,refer_nurs,refer_sp,refer_pt,refer_diet,
                 type,type_n,frequency,frequency_n,DST,DST_n,       
                 import_to,import_for,importance) %>%
          mutate(level = NA) %>%
          select(fake_id:score,level,type:importance,refer_ot:refer_diet)
        
        q3_filt <-
          sec3Input() %>%
          select(fake_id,PIHP,agency,sis_date,
                 section,section_desc,item,item_desc,qol,
                 need_svc,score,
                 refer_ot,refer_nurs,refer_sp,refer_pt,refer_diet,
                 type,type_n,frequency,frequency_n,DST,DST_n,       
                 import_to,import_for,importance) %>%
          mutate(level = NA) %>%
          select(fake_id:score,level,type:importance,refer_ot:refer_diet)
        
        q1_filt <-
          sec1Input() %>%
          select(fake_id,PIHP,agency,sis_date,
                 section,section_desc,item,item_desc,qol,
                 need_svc,score,
                 refer_ot,refer_nurs,refer_sp,refer_pt,refer_diet,
                 level) %>%
          mutate(type = NA,
                 type_n = NA,
                 frequency = NA,
                 frequency_n = NA,
                 DST = NA,
                 DST_n = NA,       
                 import_to = NA,
                 import_for = NA,
                 importance = NA) %>%
          select(fake_id:score,level,type:importance,refer_ot:refer_diet)
        
        s1_3Input <- rbind(q2_filt, q3_filt, q1_filt)
        
        rm(q2_filt); rm(q3_filt); rm(q1_filt)
        
        s1_3Input %>%
          mutate(type = ifelse(section %in% c("Q1A","Q1B"),
                               yes = level, no = type)) %>%
          select(-level)
        
      })
      
      boxInput <- reactive({
        
        sisByAgency() %>%
          filter(current_int == T) %>%
          droplevels() %>%
          select(interviewer,
                 fake_id,
                 medical = scr_1A_raw_total,
                 behavior = scr_1B_raw_total,
                 homeliving = scr_2A_std,
                 commliving = scr_2B_std,
                 hlthsafety = scr_2E_std,
                 lifelearng = scr_2C_std,
                 employment = scr_2D_std,
                 social = scr_2F_std,
                 SupportNeedsIndex = scr_support_needs_index) %>%
          mutate(ABE = homeliving + commliving + hlthsafety) %>%
          gather(subscale, score, medical:ABE, -interviewer) %>%
          mutate(subscale = car::recode(subscale, 
                                        "'medical' = 'Medical Supports';
                                        'behavior' = 'Behavioral Supports';
                                        'homeliving' = 'Home Living';
                                        'commliving' = 'Community Living';
                                        'hlthsafety' = 'Health and Safety';
                                        'lifelearng' = 'Lifelong Learning';
                                        'employment' = 'Employment';
                                        'social' = 'Social Activities';
                                        'ABE' = 'ABE Score';
                                        'SupportNeedsIndex' = 'Support Needs Index'"))
        
      })
      
      clusterInput <- reactive({
        
        #  Make dataframe for use in cluster analyses
        
        sisByAgency() %>%
          filter(is.na(fake_id) == FALSE) %>% # Remove empty randomized IDs
          # Include only most recent assessment data per ID
          group_by(fake_id) %>% 
          filter(as.Date(sis_date) == max(as.Date(sis_date))) %>% 
          ungroup() %>% droplevels() %>%
          select(contains("scr")) %>%
          rename(medical = scr_1A_raw_total,
                 behavior = scr_1B_raw_total,
                 home = scr_2A_std,
                 community = scr_2B_std,
                 safety = scr_2E_std,
                 learning = scr_2C_std,
                 employment = scr_2D_std,
                 social = scr_2F_std,
                 advocacy = scr_3_raw_total) %>%
          select(medical,behavior,home,community,safety,
                 learning,employment,social,advocacy)  %>%
          filter(is.na(medical) == F) %>%
          mutate_each(funs( as.numeric(scale(.) ))) %>% 
          filter(complete.cases(.))
        
      })
      
      cluster_km <- reactive({
        
        clusterInput() %>% 
          kmeans(centers = input$need_rows)
        
      })
      
      ## REACTIVE UI ELEMENTS ## 
      
      output$valid_date <- renderText({
        
        validate(
          need(input$dateRange[2] >= input$dateRange[1],
               "End date is earlier than start date"
          )
        )
        
        # make sure greater than 2 week difference
        validate(
          need(difftime(input$dateRange[2], input$dateRange[1], 
                        "days") > 14, "Date range less the 14 days"
          )
        )
        
        # make sure last date is in dataset range
        validate(
          need(input$dateRange[2] <= max(as.Date(scrub_sis$sis_date)[as.Date(scrub_sis$sis_date) <= Sys.Date()]), 
               "End date beyond available data"
          )
        )
        
        # make sure start date is in dataset range
        validate(
          need(input$dateRange[1] >= min(as.Date(scrub_sis$sis_date)[as.Date(scrub_sis$sis_date) <= Sys.Date()]), 
               "Start date precedes available data"
          )
        )
        
        paste("Your date range is", 
              difftime(input$dateRange[2], input$dateRange[1], units = "days"),
              "days")
        
      })
      
      output$agency <- renderUI({
        
        filtre <- if (input$region == "All") {
          levels(scrub_sis$agency)
        } else 
          levels(droplevels(scrub_sis$agency[scrub_sis$PIHP == input$region]))
        
        selectInput(
          "agency",
          label = "Pick an agency:",
          choices = c("All", filtre), 
          selected = "All"
        )
        
      })
      
      output$what_staff <- renderUI({
        
        sliderInput(
          inputId = "what_staff", 
          "...we changed the number of SIS interviewers?",
          min = on_track_vars()$recent_int * -1,
          max = on_track_vars()$recent_int,
          value = 0,
          step = 1,
          round = T
        )
        
      })
      
      output$what_prod <- renderUI({

        
        min_avg_wk <- round(on_track_vars()$avg_person_wk * 0.5, digits = 0)
        max_avg_wk <- round(on_track_vars()$avg_person_wk * 3, digits = 0)
        
        sliderInput(
          inputId = "what_prod",
          "...each interviewer completed fewer/more assessments per week?",
          min = 0,
          max = ifelse(max_avg_wk < 3, yes = 3, no = max_avg_wk),
          value = on_track_vars()$avg_person_wk,
          step = 0.5,
          round = T
        )

      })
      
      output$q2domain <- renderUI({
        tos2 <- tos2Input()
        
        filtre <- if (input$select_area_q2 == "All") {
          levels(as.factor(tos2$item_desc))
        } else 
          levels(droplevels(as.factor(tos2$item_desc[tos2$section_desc == input$select_area_q2])))
        
        selectInput("q2domain",
                    label = "Select a specific need:",
                    choices = filtre, 
                    selected = "")
      })
      
      output$q3domain <- renderUI({
        tos3 <- tos3Input()
        selectInput("q3domain",
                    label = "Select a specific need:",
                    choices = levels(droplevels(unique(as.factor(tos3$item_desc)))), 
                    selected = "")
      })
      
      output$box_opts <- renderUI({
        
        # Make subset for subscale selection
        box_sis <- boxInput()
        selectInput("box",
                    label = "Select a subscale/area:",
                    choices = levels(as.factor(box_sis$subscale)), 
                    selected = "Support Needs Index")
        
      })
      
      output$import <- renderUI({
        
        selectInput(
          "import",
          label = "Show life domains important to/for the person:",
          choices = c("All", levels(as.factor(sec2Input()$importance))), 
          selected = "All"
        )
        
      })
      
      output$id_drop <- renderUI({
        
        selectInput("id_drop",
                    label = "Select an individual:",
                    choices = levels(unique(as.factor(sisByAgency()$fake_id)))
                    )
      })
      
      output$k_vars <- renderUI({
        
        # Create multiple dropdowns, each displaying a different colname
        
        tagList(
          selectInput("kmPlot_x", "X-axis: ",
                      choices = names(clusterInput()),
                      selected = names(clusterInput())[1]),
          selectInput("kmPlot_y", "Y-axis: ",
                      choices = names(clusterInput()),
                      selected = names(clusterInput())[2]),
          selectInput("kmPlot_z", "Z-axis: ",
                      choices = names(clusterInput()),
                      selected = names(clusterInput())[3]),
          selectInput("kmPlot_size", "Size: ",
                      choices = names(clusterInput()),
                      selected = names(clusterInput())[4])
        )
        
      })
      
      ## VISUALIZATIONS ##

      output$rate <- renderValueBox({
        
        # Proportion of days in selected timeframe 
        # to days between initial date selected & due date
        elapse <- 
          as.numeric(as.POSIXct(input$dateRange[2]) - as.POSIXct(input$dateRange[1])) / 
          as.numeric(as.POSIXct(due) - as.POSIXct(input$dateRange[1])) * 100
        
        sisIn <- 
          sisByAgency() %>%
          # Filter out expired assessments (> 3 yrs old)
          filter(as.Date(sis_date) >= most_recent - (365 * 3)) %>%
          # Filter out expired assessments as of due date (> 3 yrs old)
          filter(as.Date(due) - as.Date(sis_date) <= (365 * 3)) %>%
          droplevels()
        
        # Proportion of clients interviewed in selected time period 
        # to total current clients meeting criteria
        
        pct <- 
          nlevels(as.factor(sisIn$fake_id)) /
          sum(on_track_vars()$total_needed) * 100
          
        rate <- pct / elapse * 100
        
        valueBox(
          paste0(round(rate, digits = 1), "%"), "Completion Rate", 
          icon = icon(ifelse(rate >= 100,
                             yes = "thumbs-up",
                             no = "thumbs-down")),
          color = ifelse(rate >= 100,
                         yes = "green",
                         no = "red")
        )
        
      })
      
      output$complete <- renderValueBox({
        
        sisIn <- 
          sisByAgency() %>%
          # Filter out expired assessments (> 3 yrs old)
          filter(as.Date(sis_date) >= most_recent - (365 * 3)) %>%
          # Filter out expired assessments as of due date (> 3 yrs old)
          filter(as.Date(due) - as.Date(sis_date) <= (365 * 3)) %>%
          droplevels()
        
        pct <- 
          nlevels(as.factor(sisIn$fake_id)) /
          sum(on_track_vars()$total_needed) * 100
        
        valueBox(
          paste0(round(pct, digits = 1), "%"), "Complete", 
          icon = icon("pie-chart"),
          color = "teal")
        
      })
      
      output$needperwk <- renderValueBox({
        
        avgperwk <- round(mean(per_wk()$n, na.rm = T), digits = 0)
        
        week <- seq(from = input$dateRange[1], to = due, by = "week")
        
        needed <- ceiling(on_track_vars()$total_needed / length(week))
          
        valueBox(
          paste0(round(avgperwk, digits = 1), ":",
                 round(needed, digits = 1), " per week"), 
          "Assessments Completed:Needed", 
          icon = icon("file-text"),
          color = "teal")
        
      })
      
      output$num_dt <- renderDataTable({
        
        sisByAgency() %>% 
          filter(current_int == T) %>% 
          droplevels() %>%
          group_by(interviewer) %>%
          summarize(n = n(),
                    avg_dur = round(mean(duration, na.rm = T), digits = 0),
                    first = min(as.POSIXct(sis_date))) %>% 
          ungroup() %>%
          datatable(caption = 'SIS assessment summary by Interviewer.',
                    rownames = FALSE,
                    colnames = c('Interviewer',
                                 '# Assessments','Avg minutes',
                                 'Interviewing since'),
                    extensions = c('Responsive','Buttons'),
                    options = list(pageLength = 5, lengthMenu = c(5, 15),
                                   dom = 'C<"clear">lfrtip',
                                   buttons = c('colvis'))) %>%
          formatDate(4)
      })

      output$on_track <- renderDygraph({
        
        per_wk <- per_wk()
        
        week <- seq(from = max(as.Date(per_wk$week)), to = due, by = "week")
        
        # Make projection data
        tst <- data.frame(week)
        tst$n <- NA
        
        tst$avg <- 
          seq(from = sum(per_wk$n, na.rm = T) + on_track_vars()$avg_per_wk,
              to = sum(per_wk$n, na.rm = T) + on_track_vars()$avg_per_wk * length(week),
              by = on_track_vars()$avg_per_wk
          )
        
        tst$need <- 
          seq(from = ceiling(sum(per_wk$n, na.rm = T) +
                (on_track_vars()$total_needed - 
                   sum(per_wk$n, na.rm = T)) / length(week)),
              to = sum(per_wk$n, na.rm = T) +
                ceiling((on_track_vars()$total_needed - sum(per_wk$n, na.rm = T)) / length(week)) * length(week),
              by = ceiling((on_track_vars()$total_needed - sum(per_wk$n, na.rm = T)) / length(week))
          )
        
        per_wk$week <- as.Date(per_wk$week) # Make date types the same
        
        per_wk <- rbind(per_wk,tst)
        
        per_wk <-
          per_wk %>%
          ungroup() %>%
          mutate(running = order_by(week, cumsum(n))) 
        
        per_wk$week <- as.POSIXct(per_wk$week)
        
        per_wk_srs <- as.xts(per_wk$running, order.by=per_wk$week)
        
        names(per_wk_srs)[1]<-"running"
        
        per_wk_srs$avg <- per_wk$avg
        per_wk_srs$need <- per_wk$need
        
        dygraph(per_wk_srs, main = "Cumulative SIS assessments") %>%
          dyAxis("x", label = "Week of Assessments") %>%
          dyAxis("y", label = "# SIS assessments (cumulative)",
                 valueRange = c(0, max(per_wk$need))) %>%
          dySeries("running", label = "Actual", 
                   strokeWidth = 2, fillGraph = TRUE) %>%
          dySeries("avg", label = "If trend continues",
                   strokeWidth = 2, strokePattern = "dashed") %>%
          dySeries("need", label = "To meet goal",
                   strokeWidth = 2, strokePattern = "dashed") %>%
          dyLegend(width = 400) %>%
          dyEvent(x = "2012-01-22", "Ottawa Starts", labelLoc = "bottom") %>%
          dyEvent(x = "2014-07-01", "Region Starts", labelLoc = "bottom") %>%
          dyEvent(x = "2017-09-20", "Deadline", labelLoc = "bottom") %>%
          dyRangeSelector(dateWindow = c(as.Date(input$dateRange[1]), as.Date(due)))
        
      })

      output$on_track_what_if <- renderDygraph({
        
        per_wk <- per_wk()
        
        week <- 
          # Make a sequence of dates for each week from most recent until due date
          seq(from = max(as.Date(per_wk$week)[as.Date(per_wk$week) <= Sys.Date()]), 
              to = due, by = "week") %>%
          as.data.frame() 
        
        names(week)[1] <- "week"
        
        per_wk_nxt <- week %>% mutate(n = NA)
        
        proj_per_wk <- input$what_prod * (on_track_vars()$recent_int + input$what_staff)
        
        # Cumulative performance assuming avg per week
        per_wk_nxt$avg <- 
          seq(from = sum(per_wk$n, na.rm = T) + proj_per_wk,
              to = sum(per_wk$n, na.rm = T) + proj_per_wk * nrow(week),
              by = proj_per_wk)
        
        # Cumulative amount needed per week to consistently reach goal
        per_wk_nxt$need <- 
          seq(from = ceiling(sum(per_wk$n, na.rm = T) + 
                (on_track_vars()$total_needed - 
                   sum(per_wk$n, na.rm = T)) / nrow(week)),
              to = sum(per_wk$n, na.rm = T) + ceiling((on_track_vars()$total_needed - sum(per_wk$n, na.rm = T)) / nrow(week)) * nrow(week),
              by = ceiling((on_track_vars()$total_needed - sum(per_wk$n, na.rm = T)) / nrow(week)))
                 
        # Combine historical per week data with projected data
        per_wk %<>%
          rbind(per_wk_nxt) %>%
          ungroup() %>%
          mutate(running = order_by(week, cumsum(n)),
                 week = as.POSIXct(week)) 
        
        # Make df into an xts (time sseries) object
        per_wk_srs <- as.xts(per_wk$running, order.by=per_wk$week)
        # Change name and add vars
        names(per_wk_srs)[1]<-"running"
        per_wk_srs$avg <- per_wk$avg
        per_wk_srs$need <- per_wk$need
        
        dygraph(per_wk_srs, main = "What if...? Projections") %>%
          dyAxis("x", label = "Week of Assessments") %>%
          dyAxis("y", label = "# SIS assessments (cumulative)",
                 valueRange = c(0, on_track_vars()$total_needed)) %>%
          dySeries("running", label = "Actual", 
                   strokeWidth = 2, fillGraph = TRUE) %>%
          dySeries("avg", label = "With projected changes",
                   strokeWidth = 2, strokePattern = "dashed") %>%
          dySeries("need", label = "To meet goal",
                   strokeWidth = 2, strokePattern = "dashed") %>%
          dyLegend(width = 400) %>%
          dyEvent(x = "2012-01-22", "Ottawa Starts", labelLoc = "bottom") %>%
          dyEvent(x = "2014-07-01", "Region Starts", labelLoc = "bottom") %>%
          dyEvent(x = "2017-09-20", "Deadline", labelLoc = "bottom") 
        
      })
      
      output$plans <- renderPlotly({
        
        region_filt <- if (input$region == "All") {
          levels(sec3Input()$PIHP)
        } else input$region

        agency_filt <- if (input$agency == "All") {
          levels(sec3Input()$agency)
        } else input$agency

        sec3Input() %>%
          filter(PIHP %in% region_filt
                 & agency %in% agency_filt) %>%
          group_by(fake_id) %>%
          mutate(total = type_n + DST_n + frequency_n) %>%
          select(fake_id, item_desc, total) %>%
          top_n(4) %>%
          ungroup() %>%
          group_by(item_desc) %>%
          summarize(n = n()) %>%
          ungroup() %>%
          # Reorder factor by value for barchart ordering
          mutate(item_desc = fct_reorder(item_desc, x = n, fun = sum, .desc = T)) %>%
          plot_ly(x = ~item_desc, y = ~n) %>%
          add_bars(color = ~item_desc, colors = "Set3") %>%
          layout(xaxis = list(title = "Type of Need", showticklabels = F),
                 yaxis = list(title = "# times included in planning"),
                 legend = list(xanchor = "right", yanchor = "top", x = 1, y = 1, 
                               font = list(size = 10)),
                 barmode = "stack")
        
      })
      
      output$need_import_q2 <- renderPlotly({
        
        region_filt <- if (input$region == "All") {
          levels(sec2Input()$PIHP)
        } else input$region
        
        agency_filt <- if (input$agency == "All") {
          levels(sec2Input()$agency)
        } else input$agency
        
        filt_input <-
        sec2Input() %>%
          filter(PIHP %in% region_filt
                 & agency %in% agency_filt)
        
        if ( input$import == "All") {
          filt_input <- filt_input 
        } else if ( input$import %in% levels(as.factor(filt_input$importance))) {
          filt_input <- filt_input %>% filter(importance == input$import)
        } else
          print(paste0("Error.  Unrecognized input."))
        
        if ( input$need_import_q2_measure == "Number of people with need" ) {
          filt_input %>%
            mutate(no_concern = ifelse(importance == "Not endorsed" 
                                       & type == "None", 
                                       yes = TRUE, no = FALSE)) %>%
            filter(no_concern == F) %>%
            group_by(item_desc,type) %>% # type importance
            summarize(n = n_distinct(fake_id),
                      avg = round(mean(score, na.rm = T), digits = 1)) %>%
            ungroup() %>% droplevels() %>%
            # Reorder factor by value for barchart ordering
            mutate(item_desc = fct_reorder(item_desc, x = n, 
                                           fun = sum, .desc = T)) %>%
            plot_ly(x = ~item_desc, y = ~n) %>%
            add_bars(color = ~type, 
                     colors = c("#FF0000", "#00A08A", "#F2AD00", 
                                "#F98400", "#5BBCD6")) %>%
            layout(xaxis = list(title = "Life Domain", showticklabels = F),
                   yaxis = list(title = "People with Need"),
                   legend = list(xanchor = "right", yanchor = "top", x = 1, y = 1, 
                                 font = list(size = 10)),
                   barmode = "stack")
        } else if ( input$need_import_q2_measure == "Average level of need" ) {
          filt_input %>%
            mutate(no_concern = ifelse(importance == "Not endorsed" 
                                       & type == "None", 
                                       yes = TRUE, no = FALSE)) %>%
            filter(no_concern == F) %>%
            group_by(item_desc) %>% # type importance
            summarize(n = n_distinct(fake_id),
                      avg = round(mean(score, na.rm = T), digits = 1)) %>%
            ungroup() %>% droplevels() %>%
            # Reorder factor by value for barchart ordering
            mutate(item_desc = fct_reorder(item_desc, x = avg, 
                                           fun = sum, .desc = T)) %>%
            plot_ly(x = ~item_desc, y = ~avg, type = "bar",  
                    colors = c("#FF0000", "#00A08A", "#F2AD00", 
                               "#F98400", "#5BBCD6")) %>%
            layout(xaxis = list(title = "Life Domain", showticklabels = F),
                   yaxis = list(title = "Average Score"),
                   legend = list(xanchor = "right", yanchor = "top", x = 1, y = 1, 
                                 font = list(size = 10)),
                   barmode = "stack")
        } else
          print(paste0("Error.  Unrecognized input."))
        
      })

      output$import_q2 <- renderPlotly({
        
        region_filt <- if (input$region == "All") {
          levels(sec2Input()$PIHP)
        } else input$region
        
        agency_filt <- if (input$agency == "All") {
          levels(sec2Input()$agency)
        } else input$agency
        
        sec2Input() %>%
          filter(PIHP %in% region_filt
                 & agency %in% agency_filt) %>%
          group_by(item_desc) %>%
          summarize(To = sum(as.numeric(import_to), na.rm = T),
                    For = sum(as.numeric(import_for), na.rm = T)) %>%
          gather(important, n, To:For) %>%
          ungroup() %>%
          # Reorder factor by value for barchart ordering
          mutate(item_desc = fct_reorder(item_desc, x = n, 
                                         fun = sum, .desc = T)) %>%
          plot_ly(x = ~item_desc, y = ~n) %>%
          add_bars(color = ~important, colors = c('#b2df8a', '#1f78b4')) %>%
          layout(xaxis = list(title = "Life Domain", showticklabels = F),
                 yaxis = list(title = "People with need marked as important"),
                 legend = list(xanchor = "right", yanchor = "top", x = 1, y = 1, 
                               font = list(size = 10)),
                 barmode = "stack")
        
      })

      output$tos_q2 <- renderParset({
        
        if ( input$agency == "All" & input$region == "All") {
          tos_parset <- 
            tos2Input() %>% 
            filter(item_desc == input$q2domain) %>%
            select(-item_desc,-section_desc) %>%
            group_by(type,frequency,DST,PIHP) %>%
            summarize(n = sum(n)) %>%
            arrange(desc(n))
          
          parset(
            tos_parset,
            # dimensions are the categorical columns
            dimensions = colnames(tos_parset)[-5],
            # use some JavaScript to inform parset that Freq has the value
            value = htmlwidgets::JS("function(d){return d.n}"),
            tension = 0.5,
            width = "80%", height = 400
          )
          
        } else if ( input$region %in% levels(unique(scrub_sis$PIHP)) & input$agency == "All") {
          
          tos_parset <- 
            tos2Input() %>% 
            filter(item_desc == input$q2domain
                   & PIHP == input$region) %>%
            select(-item_desc,-section_desc) %>%
            group_by(type,frequency,DST,agency) %>%
            summarize(n = sum(n)) %>%
            arrange(desc(n))
          
          parset(
            tos_parset,
            # dimensions are the categorical columns
            dimensions = colnames(tos_parset)[-5],
            # use some JavaScript to inform parset that Freq has the value
            value = htmlwidgets::JS("function(d){return d.n}"),
            tension = 0.5,
            width = "80%", height = 400
          )
        
        } else if ( input$agency %in% levels(unique(scrub_sis$agency)) ) {
          tos_parset <- 
            tos2Input() %>% 
            filter(agency == input$agency 
                   & item_desc == input$q2domain) %>%
            group_by(type,frequency,DST) %>%
            summarize(n = sum(n)) %>%
            arrange(desc(n))
          
          parset(
            tos_parset,
            # dimensions are the categorical columns
            dimensions = colnames(tos_parset)[-4],
            # use some JavaScript to inform parset that Freq has the value
            value = htmlwidgets::JS("function(d){return d.n}"),
            tension = 0.5,
            width = "80%", height = 400
          )
        } else
          print(paste0("Error.  Unrecognized input."))
        
      })
      
      output$tos_q3 <- renderParset({
        
        if ( input$agency == "All" & input$region == "All" ) {
          
          tos_parset <- 
            tos3Input() %>% 
            filter(item_desc == input$q3domain) %>%
            select(-item_desc) %>%
            group_by(type,frequency,DST,PIHP) %>%
            summarize(n = sum(n)) %>%
            arrange(desc(n))
          
          parset(
            tos_parset,
            # dimensions are the categorical columns
            dimensions = colnames(tos_parset)[-5],
            # use some JavaScript to inform parset that Freq has the value
            value = htmlwidgets::JS("function(d){return d.n}"),
            tension = 0.5,
            width = "80%", height = 400
          )
        
        } else if ( input$region %in% levels(unique(scrub_sis$PIHP)) & input$agency == "All") {
          
          tos_parset <- 
            tos3Input() %>% 
            filter(item_desc == input$q3domain
                   & PIHP == input$region) %>%
            select(-item_desc,-section_desc) %>%
            group_by(type,frequency,DST,agency) %>%
            summarize(n = sum(n)) %>%
            arrange(desc(n))
          
          parset(
            tos_parset,
            # dimensions are the categorical columns
            dimensions = colnames(tos_parset)[-5],
            # use some JavaScript to inform parset that Freq has the value
            value = htmlwidgets::JS("function(d){return d.n}"),
            tension = 0.5,
            width = "80%", height = 400
          )
          
        } else if ( input$agency %in% levels(unique(scrub_sis$agency)) ) {
          tos_parset <- 
            tos3Input() %>% 
            filter(agency == input$agency 
                   & item_desc == input$q3domain) %>%
            group_by(type,frequency,DST) %>%
            summarize(n = sum(n)) %>%
            arrange(desc(n))
          
          parset(
            tos_parset,
            # dimensions are the categorical columns
            dimensions = colnames(tos_parset)[-4],
            # use some JavaScript to inform parset that Freq has the value
            value = htmlwidgets::JS("function(d){return d.n}"),
            tension = 0.5,
            width = "80%", height = 400
          )
          
        } else
          print(paste0("Error.  Unrecognized input."))
        
      })

      output$q2_dt <- renderDataTable({
        
        filtre <- if (input$select_area_q2 == "All") {
          levels(as.factor(sec2Input()$item_desc))
        } else 
          levels(droplevels(as.factor(sec2Input()$item_desc[sec2Input()$section_desc == input$select_area_q2])))
        
        region_filt <- if (input$region == "All") {
          levels(sec2Input()$PIHP)
        } else input$region
        
        agency_filt <- if (input$agency == "All") {
          levels(sec2Input()$agency)
        } else input$agency
        
        
        if ( input$region == "All" & input$agency == "All" ) {
          
          notescope <- "by Region"
          
          df <-
            sec2Input() %>%
            filter(item_desc %in% filtre) %>%
            group_by(PIHP, item_desc) %>%
            summarize(avg = round(mean(score, na.rm = T), digits = 1)) %>%
            spread(PIHP, avg, drop = FALSE)
          
          dt_in <-sec2Input() %>%
            filter(item_desc %in% filtre) %>%
            group_by(item_desc) %>%
            summarize(avg = round(mean(score, na.rm = T), digits = 1),
                      sd = round(sd(score, na.rm = T), digits = 1)) %>% 
            left_join(df, id = "item_desc") %>%
            rename(All = avg, StDev = sd, Item = item_desc) %>%
            arrange(desc(StDev))
          
        } else if ( input$region %in% levels(unique(scrub_sis$PIHP)) & input$agency == "All" ) {
          
          notescope <- paste0("for agencies within ", input$region)
          
          df <-
            sec2Input() %>%
            filter(PIHP %in% region_filt) %>%
            filter(item_desc %in% filtre) %>%
            group_by(agency, item_desc) %>%
            summarize(avg = round(mean(score, na.rm = T), digits = 1)) %>%
            spread(agency, avg, drop = FALSE)
          
          dt_in <-sec2Input() %>%
            filter(PIHP %in% region_filt) %>%
            filter(item_desc %in% filtre) %>%
            group_by(item_desc) %>%
            summarize(avg = round(mean(score, na.rm = T), digits = 1),
                      sd = round(sd(score, na.rm = T), digits = 1)) %>% 
            left_join(df, id = "item_desc") %>%
            rename(All = avg, StDev = sd, Item = item_desc) %>%
            arrange(desc(StDev))
          
        } else if ( input$agency %in% levels(unique(scrub_sis$agency)) ) {
          
          notescope <- paste0("at ", input$agency)
          
          df <-
            sec2Input() %>%
            filter(item_desc %in% filtre) %>%
            group_by(agency, item_desc) %>%
            summarize(avg = round(mean(score, na.rm = T), digits = 1)) %>%
            filter(agency == input$agency) %>%
            spread(agency, avg, drop = FALSE)
          
          dt_in <-
            sec2Input() %>%
            filter(item_desc %in% filtre) %>%
            filter(agency != input$agency) %>%
            group_by(item_desc) %>%
            summarize(avg = round(mean(score, na.rm = T), digits = 1)) %>% 
            left_join(df, id = "item_desc") %>%
            mutate(differ = .[[3]] - .[[2]]) %>% # use col indices since names change
            rename(All.Others = avg, Difference = differ, Item = item_desc) %>%
            arrange(desc(Difference))
          
        } else
          print(paste0("Error.  Unrecognized input."))
        
        dt <-
        dt_in %>%
          datatable(caption = paste0("Variation and Average Raw Scores on Section 2 Items (",
                                     input$select_area_q2, "), ",notescope),
                    rownames = FALSE,
                    extensions = c('Responsive','Buttons'),
                    options = list(pageLength = 5, lengthMenu = c(5, 10,20),
                                   dom = 'C<"clear">lfrtip',
                                   buttons = c('colvis'))) 
        
        if ( input$agency == "All" ) {
        
          dt %>%
            formatStyle('StDev',
                        background = styleColorBar(dt_in$StDev, 'lightpink'),
                        backgroundSize = '100% 90%',
                        backgroundRepeat = 'no-repeat',
                        backgroundPosition = 'center')
          
        } else if ( input$agency %in% levels(unique(scrub_sis$agency)) ) {  
          
          dt %>%
            formatStyle('Difference',
                        background = styleColorBar(dt_in$Difference, 'lightpink'),
                        backgroundSize = '100% 90%',
                        backgroundRepeat = 'no-repeat',
                        backgroundPosition = 'center')
          
        } else
          print(paste0("Error.  Unrecognized input."))
          
      })
       
      output$q3_dt <- renderDataTable({
        
        region_filt <- if (input$region == "All") {
          levels(sec3Input()$PIHP)
        } else input$region
        
        agency_filt <- if (input$agency == "All") {
          levels(sec3Input()$agency)
        } else input$agency
        
        if ( input$region == "All" & input$agency == "All" ) {
          
          notescope <- "by Region"
          
          df <-
            sec3Input() %>%
            group_by(PIHP, item_desc) %>%
            summarize(avg = round(mean(score, na.rm = T), digits = 1)) %>%
            spread(PIHP, avg, drop = FALSE)
          
          dt_in <-sec3Input() %>%
            group_by(item_desc) %>%
            summarize(avg = round(mean(score, na.rm = T), digits = 1),
                      sd = round(sd(score, na.rm = T), digits = 1)) %>% 
            left_join(df, id = "item_desc") %>%
            rename(All = avg, StDev = sd, Item = item_desc) %>%
            arrange(desc(StDev))
          
        } else if ( input$region %in% levels(unique(scrub_sis$PIHP)) & input$agency == "All" ) {
          
          notescope <- paste0("for agencies within ", input$region)
          
          df <-
            sec3Input() %>%
            filter(PIHP %in% region_filt) %>%
            group_by(agency, item_desc) %>%
            summarize(avg = round(mean(score), digits = 1)) %>%
            spread(agency, avg, drop = FALSE)
          
          dt_in <-sec3Input() %>%
            filter(PIHP %in% region_filt) %>%
            group_by(item_desc) %>%
            summarize(avg = round(mean(score), digits = 1),
                      sd = round(sd(score), digits = 1)) %>% 
            left_join(df, id = "item_desc") %>%
            rename(All = avg, StDev = sd, Item = item_desc) %>%
            arrange(desc(StDev))
          
        } else if ( input$agency %in% levels(unique(scrub_sis$agency)) ) {
          
          notescope <- paste0("at ", input$agency)
          
          df <-
            sec3Input() %>%
            group_by(agency, item_desc) %>%
            summarize(avg = round(mean(score), digits = 1)) %>%
            filter(agency == input$agency) %>%
            spread(agency, avg, drop = FALSE)
          
          dt_in <-
            sec3Input() %>%
            filter(agency != input$agency) %>%
            group_by(item_desc) %>%
            summarize(avg = round(mean(score), digits = 1)) %>% 
            left_join(df, id = "item_desc") %>%
            mutate(differ = .[[3]] - .[[2]]) %>% # use col indices since names change
            rename(All.Others = avg, Difference = differ, Item = item_desc) %>%
            arrange(desc(Difference))
          
        } else
          print(paste0("Error.  Unrecognized input."))
        
        dt <-
          dt_in %>%
          datatable(caption = paste0("Variation and Average Raw Scores on Section 3 Items, ",
                                     notescope),
                    rownames = FALSE,
                    extensions = c('Responsive','Buttons'),
                    options = list(pageLength = 5, lengthMenu = c(5, 10,20),
                                   dom = 'C<"clear">lfrtip',
                                   buttons = c('colvis'))) 
        
        if ( input$agency == "All" ) {
          
          dt %>%
            formatStyle('StDev',
                        background = styleColorBar(dt_in$StDev, 'lightpink'),
                        backgroundSize = '100% 90%',
                        backgroundRepeat = 'no-repeat',
                        backgroundPosition = 'center')
          
        } else if ( input$agency %in% levels(unique(scrub_sis$agency)) ) {  
          
          dt %>%
            formatStyle('Difference',
                        background = styleColorBar(dt_in$Difference, 'lightpink'),
                        backgroundSize = '100% 90%',
                        backgroundRepeat = 'no-repeat',
                        backgroundPosition = 'center')
          
        } else
          print(paste0("Error.  Unrecognized input."))
          
      })
      
      output$hist_sni <- renderPlotly({
        
        if ( input$region == "All" & input$agency == "All" ) {
          notetxt <- "Distribution of scores<br>for Support Needs Index<br>across all regions"
        } else if ( input$region %in% levels(unique(scrub_sis$PIHP)) & input$agency == "All" ) {
          notetxt <- paste0("Distribution of scores<br>for Support Needs Index<br>at ",input$region)
        } else if ( input$agency %in% levels(unique(scrub_sis$agency)) ) {
          notetxt <- paste0("Distribution of scores<br>for Support Needs Index<br>at ",input$agency)
        } else
          print(paste0("Error.  Unrecognized input."))
        
        minx <- min(sisByAgency()$scr_support_needs_index, na.rm = T)
        maxx <- max(sisByAgency()$scr_support_needs_index, na.rm = T)
        sizex <- (maxx - minx) / input$sni_bins
          
        hist <-
          sisByAgency() %>%
          plot_ly(x = ~scr_support_needs_index) %>%
          add_histogram(opacity = 0.6, 
                        autobinx = F,
                        xbins = list(start = minx, 
                                     end = maxx, 
                                     size = sizex),
                        hoverinfo = "all", 
                        name = "people",
                        showlegend = F) %>%
          layout(xaxis = list(title = "Support Needs Index Score", 
                              tickmode = "array",range = c(minx, maxx), autorange = F,
                              autotick = F, tick0 = minx, dtick = sizex),
                 yaxis = list(title = "People assessed", showgrid = F),
                 legend = list(xanchor = "right", yanchor = "top", x = 1, y = 1, 
                               font = list(size = 10)),
                 annotations = list(x = minx, xanchor = "left", 
                                    y = 1, yanchor = "top", yref = "paper",
                                    showarrow = F, align = "left",
                                    text = notetxt)) 
        
        max_hist <- max(hist(sisByAgency()$scr_support_needs_index,
                             breaks=input$sni_bins)$counts,na.rm=TRUE)
        
        ifelse(
          input$central == "Mean",
          yes = hist <- hist %>% add_lines(x = rep(mean(sisByAgency()$scr_support_needs_index, 
                                                        na.rm = T), 
                                                   each = 2), 
                                           y = c(0,max_hist),
                                           line = list(dash = 5),
                                           marker = list(color = "#DA824F"),
                                           name = "Mean score",
                                           hoverinfo = "x",
                                           xaxis = "x"),
          no  = hist <- hist %>% add_lines(x = rep(median(sisByAgency()$scr_support_needs_index, 
                                                          na.rm = T), 
                                                   each = 2), 
                                           y = c(0,max_hist),
                                           line = list(dash = 5),
                                           marker = list(color = "#DA824F"),
                                           name = "Median score",
                                           hoverinfo = "x",
                                           xaxis = "x")
        )
        
        hist
        
      })

      output$norm_sni <- renderPlotly({
        
        # Calculate actual density
        dense <- density(sisByAgency()$scr_support_needs_index, 
                         kernel = "gaussian", 
                         na.rm = T)
        
        # Density of normal distribution
        norm <- density(rnorm(n = nrow(sisByAgency()), mean = 100, sd = 15),
                        kernel = "gaussian", 
                        na.rm = T)
        
        minx <- min(sisByAgency()$scr_support_needs_index, na.rm = T)
        maxx <- max(sisByAgency()$scr_support_needs_index, na.rm = T)
        sizex <- (maxx - minx) / input$norm_bins
        
        sisByAgency() %>%
          plot_ly(x = ~scr_support_needs_index) %>%
          add_histogram(opacity = 0.6,
                        autobinx = F,
                        xbins = list(start = minx, 
                                     end = maxx, 
                                     size = sizex),
                        colors = "#A9A9A9",
                        hoverinfo = "all", 
                        name = "People",
                        yaxis = "y1") %>%
          add_lines(x = dense$x,
                    y = dense$y,
                    name = "Actual Scores",
                    yaxis = "y2") %>%
          add_lines(x = norm$x,
                    y = norm$y,
                    name = "Standard Scores",
                    yaxis = "y2") %>%
          layout(title = "Actual v. Normal Distribution", 
                 yaxis1 = list(title = "People",
                               rangemode = "tozero"),
                 yaxis2 = list(overlaying = "y", 
                               side = "right", 
                               title = "Density",
                               rangemode = "tozero"),
                 xaxis = list(title = "Support Needs Index"))
        
      })
        
      output$dt_sni <- renderDataTable({
        
        clin_by_dom <-
        sisByAgency() %>%
          select(agency = agency,
                 medical = scr_1A_raw_total,
                 behavior = scr_1B_raw_total,
                 homeliving = scr_2A_std,
                 commliving = scr_2B_std,
                 hlthsafety = scr_2E_std,
                 lifelearng = scr_2C_std,
                 employment = scr_2D_std,
                 social = scr_2F_std) %>%
          group_by(agency) %>%
          summarize(n = n(),
                    medical = round(mean(medical, na.rm = T), digits = 1),
                    behavior = round(mean(behavior, na.rm = T), digits = 1),
                    homeliving = round(mean(homeliving, na.rm = T), digits = 1),
                    commliving = round(mean(commliving, na.rm = T), digits = 1),
                    hlthsafety = round(mean(hlthsafety, na.rm = T), digits = 1),
                    lifelearng = round(mean(lifelearng, na.rm = T), digits = 1),
                    employment = round(mean(employment, na.rm = T), digits = 1),
                    social = round(mean(social, na.rm = T), digits = 1)) %>%
          select(agency, medical:social) 
        
        clin_by_dom %>%
          datatable(rownames = FALSE,
                    colnames = c('Agency',
                                 'Medical','Behavioral',
                                 'Home','Community','Safety',
                                 'Learning','Employment', 'Social'),
                    caption = 'Average subscale scores by Agency',
                    extensions = c('Responsive','Buttons'),
                    options = list(pageLength = 10, 
                                   lengthMenu = c(5,10,nrow(clin_by_dom)),
                                   dom = 'C<"clear">lfrtip',
                                   buttons = c('colvis'))) %>%
          formatStyle('medical',
                      background = styleColorBar(clin_by_dom$medical, 'lightseagreen'),
                      backgroundSize = '100% 90%',
                      backgroundRepeat = 'no-repeat',
                      backgroundPosition = 'center') %>%
          formatStyle('behavior',
                      background = styleColorBar(clin_by_dom$behavior, 'lightsteelblue'),
                      backgroundSize = '100% 90%',
                      backgroundRepeat = 'no-repeat',
                      backgroundPosition = 'center') %>%
          formatStyle('homeliving',
                      background = styleColorBar(clin_by_dom$homeliving, 'lightblue'),
                      backgroundSize = '100% 90%',
                      backgroundRepeat = 'no-repeat',
                      backgroundPosition = 'center') %>%
          formatStyle('commliving',
                      background = styleColorBar(clin_by_dom$commliving, 'steelblue'),
                      backgroundSize = '100% 90%',
                      backgroundRepeat = 'no-repeat',
                      backgroundPosition = 'center') %>%
          formatStyle('hlthsafety',
                      background = styleColorBar(clin_by_dom$hlthsafety, 'darkseagreen'),
                      backgroundSize = '100% 90%',
                      backgroundRepeat = 'no-repeat',
                      backgroundPosition = 'center') %>%
          formatStyle('lifelearng',
                      background = styleColorBar(clin_by_dom$lifelearng, 'darkcyan'),
                      backgroundSize = '100% 90%',
                      backgroundRepeat = 'no-repeat',
                      backgroundPosition = 'center') %>%
          formatStyle('employment',
                      background = styleColorBar(clin_by_dom$employment, 'mediumturquoise'),
                      backgroundSize = '100% 90%',
                      backgroundRepeat = 'no-repeat',
                      backgroundPosition = 'center') %>%
          formatStyle('social',
                      background = styleColorBar(clin_by_dom$social, 'mediumaquamarine'),
                      backgroundSize = '100% 90%',
                      backgroundRepeat = 'no-repeat',
                      backgroundPosition = 'center')
        
      })
      
      output$conditions <- renderPlotly({
        
        radio <- if (input$radio_mb == "Either") {c("Medical Supports","Behavioral Supports")
        } else if (input$radio_mb == "Medical") {c("Medical Supports")
        } else if (input$radio_mb == "Behavioral") {c("Behavioral Supports")
        } else print(paste0("Error.  Unrecognized input."))
        
        region_filt <- if (input$region == "All") {
          levels(sec1Input()$PIHP)
        } else input$region
        
        agency_filt <- if (input$agency == "All") {
          levels(sec1Input()$agency)
        } else input$agency
        
        sec1Input() %>%
          filter(PIHP %in% region_filt
                 & agency %in% agency_filt) %>%
          filter(score > 0
                 & section_desc %in% radio) %>%
          group_by(item_desc,level) %>%
          summarize(n = n()) %>%
          ungroup() %>%
          # Reorder factor by value for barchart ordering
          mutate(item_desc = fct_reorder(item_desc, x = n, fun = sum, .desc = T)) %>%
          plot_ly(x = ~item_desc, y = ~n) %>%
          add_bars(color = ~level, colors = c("#F98400","#FF0000")) %>%
          layout(xaxis = list(title = "Type of Need", showticklabels = F),
                 yaxis = list(title = "People with need"),
                 legend = list(xanchor = "right", yanchor = "top", x = 1, y = 1, 
                               font = list(size = 10)),
                 barmode = "stack")
        
      })

      output$hist_mb <- renderPlotly({
        
        if ( input$region == "All" & input$agency == "All" ) {
          notescope <- "across all CMHSPs"
        } else if ( input$region %in% levels(unique(scrub_sis$PIHP)) & input$agency == "All" ) {
          notescope <- paste0("in ",input$region)
        } else if ( input$agency %in% levels(unique(scrub_sis$agency)) ) {
          notescope <- paste0("at ",input$agency)
        } else
          print(paste0("Error.  Unrecognized input."))
        
        if ( input$radio_mb == "Medical" ) {
          notetxt <- paste0("Distribution of needs<br>for medical issues<br>",
                            notescope)
          
          minx <- min(sisByAgency()$scr_1A_raw_total, na.rm = T)
          maxx <- max(sisByAgency()$scr_1A_raw_total, na.rm = T)
          sizex <- (maxx - minx) / input$mb_bins
          
          max_hist <- max(hist(sisByAgency()$scr_1A_raw_total,
                               breaks=input$mb_bins)$counts,na.rm = T)
          
          hist <-
            sisByAgency() %>%
            plot_ly(x = ~scr_1A_raw_total) %>%
            add_histogram(opacity = 0.6, 
                          autobinx = F,
                          xbins = list(start = minx, 
                                       end = maxx, 
                                       size = sizex),
                          hoverinfo = "all",  
                          name = "people",
                          showlegend = F) %>%
            layout(xaxis = list(title = "Number of medical needs", 
                                tickmode = "array",
                                range = c(minx, maxx), 
                                autorange = F,
                                autotick = F, 
                                tick0 = minx, dtick = sizex),
                   yaxis = list(title = "People assessed", showgrid = F),
                   annotations = list(x = maxx, xanchor = "right", 
                                      y = 1, yanchor = "top", yref = "paper",
                                      showarrow = F, align = "left",
                                      text = notetxt)) %>% 
            add_lines(x = rep(mean(sisByAgency()$scr_1A_raw_total, na.rm = T), 
                              each = 2), 
                      y = c(0,max_hist),
                      line = list(dash = 5),
                      #marker = list(color = "#DA824F"),
                      name = "Mean",
                      hoverinfo = "x",
                      xaxis = "x")
          
        } else if ( input$radio_mb == "Behavioral" ) {
          
          notetxt <- paste0("Distribution of needs<br>for behavioral issues<br>",
                            notescope)
          
          minx <- min(sisByAgency()$scr_1B_raw_total, na.rm = T)
          maxx <- max(sisByAgency()$scr_1B_raw_total, na.rm = T)
          sizex <- (maxx - minx) / input$mb_bins
          
          max_hist <- max(hist(sisByAgency()$scr_1B_raw_total,
                               breaks=input$mb_bins)$counts,na.rm=TRUE)
          
          hist <-
            sisByAgency() %>%
            plot_ly(x = ~scr_1B_raw_total) %>%
            add_histogram(opacity = 0.6, 
                          autobinx = F,
                          xbins = list(start = minx, 
                                       end = maxx, 
                                       size = sizex),
                          hoverinfo = "all",  
                          name = "people",
                          showlegend = F) %>%
            layout(xaxis = list(title = "Number of behavioral needs", 
                                tickmode = "array",
                                range = c(minx, maxx), 
                                autorange = F,
                                autotick = F, 
                                tick0 = minx, 
                                dtick = sizex),
                   yaxis = list(title = "People assessed", showgrid = F),
                   annotations = list(x = maxx, xanchor = "right", 
                                      y = 1, yanchor = "top", yref = "paper",
                                      showarrow = F, align = "left",
                                      text = notetxt)) %>% 
            add_lines(x = rep(mean(sisByAgency()$scr_1B_raw_total, na.rm = T), 
                              each = 2), 
                      y = c(0,max_hist),
                      line = list(dash = 5),
                      #marker = list(color = "#DA824F"),
                      name = "Mean",
                      hoverinfo = "x",
                      xaxis = "x")
          
        } else if ( input$radio_mb == "Either" ) {
          
          notetxt <- paste0("Distribution of needs<br>for both medical issues<br>and behavioral issues<br>",
                            notescope)
          
          minx <- min(sisByAgency()$scr_1A_raw_total, sisByAgency()$scr_1B_raw_total, na.rm = T)
          maxx <- max(sisByAgency()$scr_1A_raw_total, sisByAgency()$scr_1B_raw_total, na.rm = T)
          sizex <- (maxx - minx) / input$mb_bins
          
          max_hist <- max(hist(sisByAgency()$scr_1A_raw_total,
                               breaks=input$mb_bins)$counts
                          + hist(sisByAgency()$scr_1B_raw_total,
                                 breaks=input$mb_bins)$counts,
                          na.rm = T)
          
          hist <-
            sisByAgency() %>%
            plot_ly(x = ~(scr_1A_raw_total + scr_1B_raw_total)) %>%
            add_histogram(opacity = 0.6, 
                          autobinx = F,
                          xbins = list(start = minx, 
                                       end = maxx, 
                                       size = sizex),
                          hoverinfo = "all",  
                          name = "people",
                          showlegend = F) %>%
            layout(xaxis = list(title = "Combined medical and behavioral needs (per person)", 
                                tickmode = "array",
                                range = c(minx, maxx), 
                                autorange = F,
                                autotick = F, 
                                tick0 = minx, dtick = sizex),
                   yaxis = list(title = "People assessed", showgrid = F),
                   annotations = list(x = maxx, xanchor = "right", 
                                      y = 1, yanchor = "top", yref = "paper",
                                      showarrow = F, align = "left",
                                      text = notetxt)) %>% 
            add_lines(x = rep(mean(sisByAgency()$scr_1A_raw_total), 
                              each = 2), 
                      y = c(0,max_hist),
                      line = list(dash = 5),
                      #marker = list(color = "#DA824F"),
                      name = "Mean",
                      hoverinfo = "x",
                      xaxis = "x")
        } else
          print(paste0("Error.  Unrecognized input."))
         
        hist
        
      })
      
      output$box_int <- renderPlotly({
        
        # Make an interviewer key
        box_df <- boxInput() 
        int_nm <- unique(box_df$interviewer)
        int_id <- c() #create an empty vec
        n <- 1 # Set initial num
        for (i in unique(box_df$interviewer)) {
          int_id <- c(int_id,
                      paste0("Interviewer ", 
                             as.character(n)))
          n <- n + 1
        }
        int_df <- data.frame(int_nm)
        int_df <- int_df %>% arrange(int_nm)
        int_df$int_id <- as.factor(int_id)
        rm(int_id); rm(int_nm)
        
        boxInput() %>%
          left_join(int_df, by = c("interviewer" = "int_nm")) %>%
          filter(subscale == input$box) %>%
          plot_ly(x = ~score, color = ~int_id, type = "box") %>%
          plotly::layout(yaxis = list(title = "Interviewers",
                                      showticklabels = F))
          
      })
      
      output$ipos_need <- renderDataTable({
        
        withProgress(message = 'Checking...',
                     detail = 'personal preferences',
                     value = 0.1, 
                     {
                       # Display Section or QOL area based on user input
                       if ( input$pick_dom == "SIS Section") {
                         DT_in <- s1_3Input() %>% rename(domain = section_desc)
                       } else if (input$pick_dom == "QOL Domain") {
                         DT_in <- s1_3Input() %>% rename(domain = qol)
                       } else
                         print(paste0("Error.  Unrecognized input."))
                       
                       # Filter needs displayed based on user selection
                       if ( input$filter_ipos == "Important to or for this person") {
                         DT_in %<>% filter(import_to == T | import_for == T) 
                       } else if (input$filter_ipos == "Important to/for, or in a higher risk area") {
                         DT_in %<>% filter(import_to == T | import_for == T | need_svc == T)
                       } else if (input$filter_ipos == "All needs") {
                         DT_in <- DT_in
                       } else
                         print(paste0("Error.  Unrecognized input."))
                       
                       DT_in %>%
                         group_by(fake_id) %>%
                         filter(fake_id == input$id_drop
                                & as.Date(sis_date) == max(as.Date(sis_date))) %>%
                         filter(!grepl("^Q1",section)) %>% # Exclude Section 1 items
                         filter(score > 0) %>%
                         arrange(domain,desc(score)) %>%
                         ungroup() %>%
                         select(domain,item_desc,score,
                                type,frequency,DST,importance) %>%
                         datatable(
                           rownames = F,
                           colnames = c('Area','Need','Score',
                                        'Type of Support','Frequency','Daily Support Time',
                                        'Important To/For'),
                           options = list(pageLength = nrow(DT_in),
                                          dom = 't')
                         ) %>%
                         formatStyle(
                           'score',
                           color = styleInterval(c(6), c("#800026","#ffffcc")),
                           backgroundColor = styleInterval(c(1:8), brewer.pal(9,"YlOrRd")) 
                         )
                       
                     })
        
      })
      
      output$ipos_mb <- renderDataTable({
        
        withProgress(message = 'Identifying...',
                     detail = 'personal needs',
                     value = 0.1, 
                     {
                       # Display Section or QOL area based on user input
                       if ( input$pick_dom == "SIS Section") {
                         DT_in <- s1_3Input() %>% rename(domain = section_desc)
                       } else if (input$pick_dom == "QOL Domain") {
                         DT_in <- s1_3Input() %>% rename(domain = qol)
                       } else
                         print(paste0("Error.  Unrecognized input."))
                       
                       DT_in %>% 
                         group_by(fake_id) %>%
                         filter(fake_id == input$id_drop
                                & as.Date(sis_date) == max(as.Date(sis_date))) %>%
                         filter(grepl("^Q1",section)) %>% # Include only Section 1 items
                         filter(score > 0) %>%
                         arrange(domain,desc(score)) %>%
                         ungroup() %>%
                         select(domain,item_desc,score,
                                type) %>%
                         datatable(
                           rownames = F,
                           colnames = c('Area','Need','Score','Type of Support'),
                           options = list(pageLength = nrow(DT_in),
                                          dom = 't')
                         ) %>%
                         formatStyle(
                           'score',
                           color = styleInterval(c(6), c("#800026","#ffffcc")),
                           backgroundColor = styleInterval(c(1:8), brewer.pal(9,"YlOrRd"))
                         ) %>%
                         formatStyle(
                           'type', 
                           color = styleEqual(c("Some Support Needed","Extensive Support Needed"), 
                                              c("#800026", "#fc4e2a")),
                           fontWeight = styleEqual(c("Some Support Needed","Extensive Support Needed"), 
                                                   c('bold', 'bold'))
                         )
                     })

      })
      
      output$ipos_pccls <- renderDataTable({
        
        withProgress(message = 'Listing...',
                     detail = 'needs for PC/CLS',
                     value = 0.1, 
                     {
                       pccls <- svs2sis(c("T1020","H2016"))
                       
                       if ( input$pick_dom == "SIS Section") {
                         
                         DT_in <-
                           s1_3Input() %>% 
                           group_by(fake_id) %>%
                           filter(fake_id == input$id_drop
                                  & as.Date(sis_date) == max(as.Date(sis_date))) %>%
                           filter(item %in% pccls$item) %>%
                           filter(need_svc == T) %>%  
                           filter(score > 0) %>%
                           arrange(desc(score)) %>%
                           ungroup() %>%
                           select(frequency,DST,type,score,
                                  section_desc,item_desc) 
                         
                       } else if (input$pick_dom == "QOL Domain") {
                         
                         DT_in <-
                           s1_3Input() %>% 
                           group_by(fake_id) %>%
                           filter(fake_id == input$id_drop
                                  & as.Date(sis_date) == max(as.Date(sis_date))) %>%
                           filter(item %in% pccls$item) %>%
                           filter(need_svc == T) %>%  
                           filter(score > 0) %>%
                           arrange(desc(score)) %>%
                           ungroup() %>%
                           select(frequency,DST,type,score,
                                  qol,item_desc) 
                         
                       } else
                         print(paste0("Error.  Unrecognized input."))
                       
                       DT_in %>%
                         datatable(
                           rownames = F,
                           colnames = c('Frequency','Daily Support Time','Type of Support',
                                        'Score','Area','Need'),
                           options = list(pageLength = nrow(DT_in),
                                          dom = 't')
                         ) %>%
                         formatStyle(
                           'type', 
                           fontWeight = styleEqual(c("Some Support Needed","Extensive Support Needed"), 
                                                   c('bold', 'bold'))
                         )
                     })
        
      })
      
      output$ipos_refer <- renderDataTable({
        
        withProgress(message = 'Thinking...',
                     detail = 'of potential referrals',
                     value = 0.1, 
                     {DT_in <-
                       s1_3Input() %>% 
                       group_by(fake_id) %>%
                       filter(fake_id == input$id_drop
                              & as.Date(sis_date) == max(as.Date(sis_date))) %>%
                       filter(grepl("^Q1",section)) %>% # Include only Section 1 items
                       filter(need_svc == T | import_to == T | import_for == T) %>% 
                       filter(refer_ot == T | refer_nurs== T | refer_sp == T 
                              | refer_pt == T | refer_diet == T) %>%
                       filter(score > 0) %>%
                       ungroup() %>%
                       gather(refer_to,YorN,refer_ot:refer_diet) %>%
                       filter(YorN == T) %>%
                       mutate(refer_to = recode(refer_to,
                                                "'refer_ot' = 'Occupational Therapy';
                                                'refer_nurs' = 'Nursing';
                                                'refer_sp' = 'Speech Pathology';
                                                'refer_pt' = 'Physical Therapy';
                                                'refer_diet' = 'Dietician'")) %>%
                       select(refer_to,item_desc,YorN) %>%
                       group_by(refer_to) %>%
                       summarize(related_needs = paste(item_desc, collapse=", "),
                                 # Concatenate needs
                                 needs = n()) %>%
                       ungroup() %>%
                       arrange(desc(needs)) %>%
                       select(-needs)
                     
                     DT_in %>%
                         datatable(
                           rownames = F,
                           colnames = c("Consider referral to:","Needs noted in SIS"),
                           options = list(pageLength = nrow(DT_in),
                                          dom = 't')
                         )
                     })
        
      }) 
      
      output$sis_svc_ntwk <- renderVisNetwork({
        
        withProgress(message = 'Creating network map ',
                     detail = 'making connections...',
                     value = 0.1, 
                     {
                       tst_need <- needs_matrix
                       rownames(tst_need) <- tst_need$Code
                       tst_need <- 
                         tst_need %>% 
                         select(-Code) %>% 
                         t() %>% 
                         as.data.frame()
                       
                       tst_need$item <- rownames(tst_need)
                       
                       region_filt <- if (input$region == "All") {
                         levels(scrub_sis$PIHP)
                       } else input$region
                       
                       agency_filt <- if (input$agency == "All") {
                         levels(scrub_sis$agency)
                       } else input$agency
                       
                       sis2svc_network <-
                         s1_3Input() %>%
                         filter(PIHP %in% region_filt
                                & agency %in% agency_filt) %>%
                         # Identify areas with identified need (>0)
                         filter(score > 0) %>%
                         # Include only endorsed or high need items
                         filter(need_svc == T | import_to == T | import_for == T) %>%
                         select(item,item_desc,score) %>%
                         left_join(tst_need, by = "item") %>%
                         group_by(item) %>%
                         gather(HCPCS,need_mapped,everything(),-item,-item_desc,-score) %>%
                         filter(need_mapped == T) %>%
                         left_join(codemap, by = "HCPCS") %>%
                         select(from = item_desc,
                                to = short_desc,
                                score) %>%
                         group_by(from,to) %>%
                         summarize(avg_score = mean(score),
                                   n = n())
                       
                       nodes <-
                         unique(c(unique(as.character(sis2svc_network$from)),
                                  unique(as.character(sis2svc_network$to)))) %>%
                         data.frame("name_id" = .) %>%
                         # Alphabetize
                         arrange(name_id) %>%
                         # Assign ids starting at 0
                         mutate(id = row_number(name_id)-1,
                                group = ifelse(name_id %in% sis2svc_network$from,
                                               yes = "Needs", no = "Services"))
                       
                       edges <-
                         sis2svc_network %>%
                         ungroup() %>%
                         left_join(nodes, by = c("from" = "name_id")) %>%
                         select(-from) %>%
                         rename(from = id) %>%
                         left_join(nodes, by = c("to" = "name_id")) %>%
                         select(-to) %>%
                         rename(to = id,
                                value = n) %>%
                         mutate(title = paste0(value," people have this need.  ",
                                               "<br>The average score is ", 
                                               round(avg_score, digits = 1))) %>%
                         droplevels()
                       
                       # Calculate degree of node to use as size
                       # Degree = number of edges attached to a given node
                       deg_from <-
                         edges %>%
                         ungroup() %>%
                         group_by(from) %>%
                         summarize(degree = n_distinct(to)) %>%
                         select(id = from, degree)
                       
                       deg <-
                         edges %>%
                         ungroup() %>%
                         group_by(to) %>%
                         summarize(degree = n_distinct(from)) %>%
                         select(id = to, degree) %>%
                         rbind(deg_from) %>%
                         ungroup()
                       
                       nodes %<>% 
                         left_join(deg, by = "id") %>%
                         rename(value = degree,
                                label = name_id)
                       
                       #nodes <- nodes() %>% rename(label = name)
                       
                       visNetwork(nodes, edges, height = "700px", width = "100%") %>% 
                         visOptions(highlightNearest = list(enabled = T, degree = 1, hover = F)) %>%
                         visEdges(color = list(color = "#E0EEEE", highlight = "#E1AF00")) %>%
                         visPhysics(maxVelocity = 5,stabilization = FALSE) %>%
                         visLayout(randomSeed = 123) %>%
                         visLegend(width = 0.1, position = "right")
                     })
        
      })
      
      output$ipos_svs <- renderDataTable({
        
        withProgress(message = 'Thinking...',
                     detail = 'of relevant services',
                     value = 0.1, 
                     {
                       tst_need <- needs_matrix
                       rownames(tst_need) <- tst_need$Code
                       tst_need <- 
                         tst_need %>% 
                         select(-Code) %>% 
                         t() %>% 
                         as.data.frame()
                       
                       tst_need$item <- rownames(tst_need)
                       
                       DT_in <-
                         s1_3Input() %>%
                         filter(fake_id == input$id_drop) %>%
                         filter(as.Date(sis_date) == max(as.Date(sis_date))) %>%
                         # Identify areas with identified need (>0)
                         filter(score > 0) %>%
                         # Include only endorsed or high need items
                         filter(need_svc == T | import_to == T | import_for == T) %>%
                         select(item,item_desc,score) %>%
                         left_join(tst_need, by = "item") %>%
                         group_by(item) %>%
                         gather(HCPCS,need_mapped,everything(),-item,-item_desc,-score) %>%
                         filter(need_mapped == T) %>%
                         select(-need_mapped) %>%
                         left_join(codemap, by = "HCPCS") %>%
                         filter(ServiceType == input$svc_typ) %>%
                         select(-med_unitcost) %>%
                         ungroup() %>%
                         group_by(short_desc,HCPCS) %>%
                         summarize(related_needs = paste(item_desc, collapse=", "),
                                   # Concatenate needs
                                   needs = n(),
                                   score = sum(score, na.rm = F)) %>%
                         arrange(desc(needs),desc(score)) 
                       
                       DT_in %>%
                         datatable(
                           rownames = F,
                           colnames = c("Service","Code","Related needs from SIS",
                                        "Needs Addressed","Intensity of Need"),
                           options = list(pageLength = nrow(DT_in),
                                          dom = 't')) %>%
                         formatStyle('needs',
                                     background = styleColorBar(DT_in$needs, 'gray'),
                                     backgroundSize = '100% 90%',
                                     backgroundRepeat = 'no-repeat',
                                     backgroundPosition = 'center') %>%
                         formatStyle('score',
                                     background = styleColorBar(DT_in$score, 'gray'),
                                     backgroundSize = '100% 90%',
                                     backgroundRepeat = 'no-repeat',
                                     backgroundPosition = 'center')
                     })
        
        
      })
      
      output$need_scree <- renderPlotly({
        
        scree <- function(df) {
          wss <- (nrow(df)-1)*sum(apply(df,2,var))
          for (i in 2:15) wss[i] <- sum(kmeans(df,centers=i)$withinss)
          wss %<>% as.data.frame() 
          names(wss)[1] <- "wss"
          wss %<>% mutate(n_clust = row_number())
          return(wss)
        }

        clusterInput() %>%
          scree() %>%
          plot_ly(x = ~n_clust, y = ~wss, height = 200) %>%
          add_lines(alpha = 0.5) %>%
          add_markers(name = "Clusters",
                      hoverinfo = "x") %>%
          layout(xaxis = list(title = "Number of clusters"),
                 yaxis = list(title = "Within groups <br>sum of squares")) %>%
          hide_legend()
        
      })
      
      output$need_heat <- renderD3heatmap({

        withProgress(message = 'Creating heatmap...',
                     detail = 'Clustering can take awhile...',
                     value = 0.1, 
                     {d3heatmap(clusterInput(), 
                                colors = "Blues",
                                dendrogram = "row",
                                k_row = input$need_rows, 
                                theme = "",
                                yaxis_font_size =  "0pt",
                                show_grid = F)
                     })
        
      })
      
      output$need_grp_dt <- DT::renderDataTable({
        
        if (input$dt_clust_type == "k-means clusters") {
          
          tidy_grp <- 
            cluster_km() %>% 
            tidy() %>%
            select(cluster,size,everything(),-withinss) %>%
            mutate_each(funs = funs(round(.,digits = 3)),
                        starts_with("x"))
          
          # Define color interval breaks
          brks <- tidy_grp %>% select(starts_with("x")) %>% 
            quantile(probs = seq(.05, .95, .05), na.rm = TRUE)
          
          clrs <- round(seq(255, 40, length.out = length(brks) + 1), 0) %>%
          {paste0("rgb(255,", ., ",", ., ")")}  
          
          # Select var names to apply color gradient
          var_names <- tidy_grp %>% select(starts_with("x")) %>% colnames()
          
        } else if (input$dt_clust_type == "hierarchical clusters") {
          
          # Use default dist and hclust methodds to match d3heatmap output
          distances <- dist(clusterInput(), method = "euclidean")
          hc <- hclust(distances, method = "complete")
          cluster <- cutree(hc, k = input$need_rows)
          
          n_obs <-
            clusterInput() %>%
            cbind(cluster) %>%
            mutate(cluster = as.factor(cluster)) %>%
            group_by(cluster) %>%
            summarize(size = n()) 
          
          tidy_grp <-
            clusterInput() %>%
            cbind(cluster) %>%
            mutate(cluster = as.factor(cluster)) %>%
            group_by(cluster) %>%
            summarize_at(vars(medical:advocacy), mean) %>%
            left_join(n_obs, by = "cluster") %>%
            select(cluster,size,everything()) %>%
            mutate_each(funs = funs(round(.,digits = 3)),
                        medical:advocacy)
          
          # Define color interval breaks
          brks <- tidy_grp %>% select(medical:advocacy) %>% as.matrix() %>%
            quantile(probs = seq(.05, .95, .05), na.rm = TRUE)
          
          clrs <- round(seq(255, 40, length.out = length(brks) + 1), 0) %>%
          {paste0("rgb(255,", ., ",", ., ")")}  
          
          # Select var names to apply color gradient
          var_names <- tidy_grp %>% select(medical:advocacy) %>% colnames()
          
        } else print(paste0("Error.  Unrecognized input."))
        
        
        # Make datatable
        tidy_grp %>%
          datatable(rownames = FALSE,
                    colnames = c('Cluster','People',colnames(cluster_km()$centers)),
                    extensions = c('Responsive','Buttons'),
                    options = list(dom = 't', buttons = c('colvis'))) %>%
          # Doesn't currently match levels of palette applied to need_km output
          # formatStyle('cluster', 
          #             backgroundColor = styleEqual(unique(tidy_k$cluster),
          #                                          soft_12[1:length(cluster_km()$centers[,1])])) %>%
          formatStyle(var_names, backgroundColor = styleInterval(brks, clrs)) %>%
          formatStyle('size',
                      background = styleColorBar(tidy_grp$size, 'gray'),
                      backgroundSize = '100% 90%',
                      backgroundRepeat = 'no-repeat',
                      backgroundPosition = 'center')
        
      })
      
      output$need_km <- renderPlotly({
        
        df <-
        cluster_km() %>% 
          augment(clusterInput()) 
        
        # Rename cols based on inputs
        df$xvar <- df[ ,which( colnames(df) == input$kmPlot_x )]
        df$yvar <- df[ ,which( colnames(df) == input$kmPlot_y )]
        df$zvar <- df[ ,which( colnames(df) == input$kmPlot_z )]
        df$sizevar <- df[ ,which( colnames(df) == input$kmPlot_size )]
        
        df %>%
          group_by(.cluster) %>%
          plot_ly(x = ~xvar, 
                  y = ~yvar, 
                  z = ~zvar,
                  p = ~sizevar,
                  hoverinfo = 'text',
                  text = ~paste(input$kmPlot_x, '(x): ', round(xvar, digits = 2),
                                '</br>', input$kmPlot_y, '(y): ', round(yvar, digits = 2),
                                '</br>', input$kmPlot_z, '(z): ', round(zvar, digits = 2),
                                '</br>', input$kmPlot_size, '(size): ', round(sizevar, digits = 2)),
                  color = ~.cluster,
                  colors = soft_12) %>%
          add_markers(size = ~sizevar, 
                      sizes = c(10, 500)) %>%
          layout(scene = list(xaxis = list(title = input$kmPlot_x), 
                              yaxis = list(title = input$kmPlot_y), 
                              zaxis = list(title = input$kmPlot_z)))
        
      })
      
      output$dt_datqual <- DT::renderDataTable({
        
        is_current <- if(input$current == "Current assessors") {
          c(TRUE)
        } else if(input$current == "All Assessors") {
          c(TRUE, FALSE)
        } else print(paste0("Error.  Unrecognized input."))
        
        # Sum number of assessments with no "Important to" fields completed
        imp_to <-
          sisByAgency() %>%
          filter(current_int %in% is_current) %>%
          group_by(interviewer,fake_id) %>%
          select(interviewer,fake_id,ends_with("_ImportantTo")) %>%
          gather(field,n,ends_with("_ImportantTo")) %>%
          summarize(n_to = sum(n, na.rm = T)) %>%
          ungroup() %>%
          filter(n_to == 0) %>%
          group_by(interviewer) %>%
          summarize(no_to = n())
          
        # Sum number of assessments with no "Important to" fields completed
        imp_for <-
          sisByAgency() %>%
          filter(current_int %in% is_current) %>%
          group_by(interviewer,fake_id) %>%
          select(interviewer,fake_id,ends_with("_ImportantFor")) %>%
          gather(field,n,ends_with("_ImportantFor")) %>%
          summarize(n_for = sum(n, na.rm = T)) %>%
          ungroup() %>%
          filter(n_for == 0) %>%
          group_by(interviewer) %>%
          summarize(no_for = n())
        
        mia <-
          sisByAgency() %>%
          filter(current_int %in% is_current) %>%
          group_by(interviewer) %>%
          summarize(miss_start = sum(as.numeric(hour(start) %in% c(0, NA))),
                    miss_end = sum(as.numeric(hour(end) %in% c(0, NA))),
                    miss_reason = sum(is.na(sis_why)),
                    not_mich = sum(as.numeric(sis_cl_st != "MI"))) %>%
          left_join(imp_to, by = "interviewer") %>%
          left_join(imp_for, by = "interviewer")
        
        mia %>%
          datatable(rownames = FALSE,
                    colnames = c('Interviewer',
                                 'Missing Start Time',
                                 'Missing End Time',
                                 'Missing Reason',
                                 'State other than MI',
                                 'No Important To',
                                 'No Important For'),
                    caption = 'Data Quality Issues, by Interviewer',
                    extensions = c('Responsive','Buttons'),
                    options = list(pageLength = 5, lengthMenu = c(5, 10,20),
                                   dom = 'C<"clear">lfrtip',
                                   buttons = c('colvis'))) %>%
          formatStyle('miss_start',
                      background = styleColorBar(mia$miss_start, 'lightsteelblue'),
                      backgroundSize = '100% 90%',
                      backgroundRepeat = 'no-repeat',
                      backgroundPosition = 'center') %>%
          formatStyle('miss_end',
                      background = styleColorBar(mia$miss_end, 'lightblue'),
                      backgroundSize = '100% 90%',
                      backgroundRepeat = 'no-repeat',
                      backgroundPosition = 'center') %>%
          formatStyle('miss_reason',
                      background = styleColorBar(mia$miss_reason, 'lightblue'),
                      backgroundSize = '100% 90%',
                      backgroundRepeat = 'no-repeat',
                      backgroundPosition = 'center') %>%
          formatStyle('not_mich',
                      background = styleColorBar(mia$not_mich, 'darkseagreen'),
                      backgroundSize = '100% 90%',
                      backgroundRepeat = 'no-repeat',
                      backgroundPosition = 'center') %>%
          formatStyle('no_to',
                      background = styleColorBar(mia$no_to, 'steelblue'),
                      backgroundSize = '100% 90%',
                      backgroundRepeat = 'no-repeat',
                      backgroundPosition = 'center') %>%
          formatStyle('no_for',
                      background = styleColorBar(mia$no_for, 'darkseagreen'),
                      backgroundSize = '100% 90%',
                      backgroundRepeat = 'no-repeat',
                      backgroundPosition = 'center')
          
        
      })
      
    }
  )
      